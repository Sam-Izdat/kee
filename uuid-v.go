// Copyright 2011 Google Inc.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package kee

import(
    "encoding/binary"
    "crypto/md5"
    "crypto/sha1"
    "errors"
    "hash"
)

// NewV1 returns a Version 1 UUID based on the current NodeID and clock
// sequence, and the current time.  If the NodeID has not been set by SetNodeID
// or SetNodeInterface then it will be set automatically.  If the NodeID cannot
// be set NewUUID returns nil.  If clock sequence has not been set by
// SetClockSequence then it will be set automatically.  If GetTime fails to
// return the current NewUUID returns nil.
func (c uuidCtrl) NewV1() (uuid, error) {
    if node.nodeID == nil {
        c.SetNodeInterface("")
    }

    now, err := GetTime()
    if err != nil {
        return c.newInst([]byte{}, err)
    }

    bytes := make([]byte, 16)

    time_low := uint32(now & 0xffffffff)
    time_mid := uint16((now >> 32) & 0xffff)
    time_hi := uint16((now >> 48) & 0x0fff)
    time_hi |= 0x1000 // Version 1

    binary.BigEndian.PutUint32(bytes[0:], time_low)
    binary.BigEndian.PutUint16(bytes[4:], time_mid)
    binary.BigEndian.PutUint16(bytes[6:], time_hi)
    binary.BigEndian.PutUint16(bytes[8:], clock_seq)
    copy(bytes[10:], node.nodeID)

    return c.newInst(bytes, nil)
}

// May need some refactoring
func (c uuidCtrl) NewV2() (uuid, error) {
    return uuid{}, errors.New("No.")
}

// NewMD5 returns a new MD5 (Version 3) UUID based on the
// supplied name space and data.
// Furst
func (c uuidCtrl) NewV3(id uuid, data []byte) (uuid, error) {
    space := id.slc
    return c.newInst(c.newHash(md5.New(), space, data, 3), nil)
}

// NewV4 returns a Random (Version 4) UUID or panics.
//
// The strength of the UUIDs is based on the strength of the crypto/rand
// package.
//
// A note about uniqueness derived from from the UUID Wikipedia entry:
//
//  Randomly generated UUIDs have 122 random bits.  One's annual risk of being
//  hit by a meteorite is estimated to be one chance in 17 billion, that
//  means the probability is about 0.00000000006 (6 × 10−11),
//  equivalent to the odds of creating a few tens of trillions of UUIDs in a
//  year and having one duplicate.
func (c uuidCtrl) NewV4() (uuid, error) {
    bytes := make([]byte, 16)
    randomBits(bytes)
    bytes[6] = (bytes[6] & 0x0f) | 0x40 
    bytes[8] = (bytes[8] & 0x3f) | 0x80 
    return c.newInst(bytes, nil)
}

// NewV5 returns a new SHA1 (Version 5) UUID based on the
// supplied name space and data.
func (c uuidCtrl) NewV5(id uuid, data []byte) (uuid, error) {
    space := id.slc
    return c.newInst(c.newHash(sha1.New(), space, data, 5), nil)
}

// NewHash returns a new UUID dervied from the hash of space concatenated with
// data generated by h.  The hash should be at least 16 byte in length.  The
// first 16 bytes of the hash are used to form the UUID.  The version of the
// UUID will be the lower 4 bits of version.  NewHash is used to implement
// NewMD5 and NewSHA1.
func (_ uuidCtrl) newHash(h hash.Hash, space []byte, data []byte, version int) []byte {
    h.Reset()
    h.Write(space)
    h.Write([]byte(data))
    s := h.Sum(nil)
    bytes := make([]byte, 16)
    copy(bytes, s)
    bytes[6] = (bytes[6] & 0x0f) | uint8((version&0xf)<<4)
    bytes[8] = (bytes[8] & 0x3f) | 0x80 // RFC 4122 variant
    return bytes
}